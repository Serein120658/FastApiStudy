# SQLAlchemy 数据库操作学习笔记

## 一、什么是 SQLAlchemy?

SQLAlchemy 是 Python 中最流行的 ORM (对象关系映射) 工具。它可以让我们用 Python 类来操作数据库,而不需要直接写 SQL 语句。

### 1.1 为什么需要 ORM?

**传统方式 (直接写 SQL):**

```python
# 需要手动写 SQL 语句
cursor.execute("INSERT INTO users (name, email) VALUES (?, ?)", ("张三", "zhang@example.com"))
cursor.execute("SELECT * FROM users WHERE id = ?", (1,))
```

**使用 ORM:**

```python
# 用 Python 对象操作
user = User(name="张三", email="zhang@example.com")
db.add(user)
db.commit()

user = db.query(User).filter(User.id == 1).first()
```

**ORM 的优势:**

- 不需要写 SQL 语句,用 Python 代码操作数据库
- 自动处理不同数据库的差异 (MySQL、PostgreSQL、SQLite 等)
- 防止 SQL 注入攻击
- 代码更易读、更易维护

## 二、安装和基础配置

### 2.1 安装依赖

```bash
# 安装 SQLAlchemy
pip install sqlalchemy

# 安装数据库驱动
# SQLite (Python 自带,无需安装)
pip install aiosqlite  # 异步版本

# MySQL
pip install pymysql
pip install aiomysql  # 异步版本

# PostgreSQL
pip install psycopg2-binary
pip install asyncpg  # 异步版本
```

这里练习就使用 aiomysql 了

![image-20251223212120482](05.数据库连接与模型.assets/image-20251223212120482.png)

先激活 ,这样就可以将下载的包安装到虚拟的环境

```bash
conda activate fastapi-env
```

![image-20251223212909585](05.数据库连接与模型.assets/image-20251223212909585.png)

如果启动过程中遇到下面的情况，那说明端口被占用了，考虑更换端口进行启动

```bash
 uvicorn main:app --reload --port 8500
```



### 2.2 项目结构

```
my_project/
├── main.py              # 主应用
├── database.py          # 数据库配置
├── models.py            # 数据库模型
├── schemas.py           # Pydantic 模型
├── crud.py              # 数据库操作函数
└── routers/
    └── users.py         # 路由
```

### 2.3 数据库配置 (database.py)

```python
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

# 数据库 URL 格式
# SQLite: sqlite:///./database.db
# MySQL: mysql+pymysql://user:password@localhost/dbname
# PostgreSQL: postgresql://user:password@localhost/dbname

# 使用 SQLite 作为示例 (最简单,不需要安装额外数据库)
SQLALCHEMY_DATABASE_URL = "sqlite:///./myapp.db"

# 创建数据库引擎
# connect_args={"check_same_thread": False} 仅用于 SQLite
engine = create_engine(
    SQLALCHEMY_DATABASE_URL,
    connect_args={"check_same_thread": False}
)

# 创建 Session 类
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# 创建基类
Base = declarative_base()

# 依赖注入:获取数据库会话
def get_db():
    """
    创建数据库会话,用完后自动关闭
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

## 三、定义数据库模型

### 3.1 基础模型 (models.py)

```python
from sqlalchemy import Column, Integer, String, Float, Boolean, DateTime
from sqlalchemy.sql import func
from database import Base

class User(Base):
    """用户表"""
    __tablename__ = "users"  # 表名
    
    # 定义字段
    id = Column(Integer, primary_key=True, index=True)  # 主键,自动递增
    username = Column(String(50), unique=True, index=True, nullable=False)  # 唯一,不能为空
    email = Column(String(100), unique=True, index=True, nullable=False)
    hashed_password = Column(String(200), nullable=False)
    is_active = Column(Boolean, default=True)  # 默认值
    created_at = Column(DateTime(timezone=True), server_default=func.now())  # 创建时间
    
    def __repr__(self):
        """打印对象时显示的内容"""
        return f"<User(id={self.id}, username={self.username})>"

class Product(Base):
    """商品表"""
    __tablename__ = "products"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), nullable=False)
    description = Column(String(500))
    price = Column(Float, nullable=False)
    stock = Column(Integer, default=0)
    is_available = Column(Boolean, default=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    def __repr__(self):
        return f"<Product(id={self.id}, name={self.name}, price={self.price})>"
```

### 3.2 常用字段类型

```python
from sqlalchemy import Column, Integer, String, Float, Boolean, DateTime, Text, Date, Time

class Example(Base):
    __tablename__ = "examples"
    
    # 整数类型
    id = Column(Integer, primary_key=True)
    age = Column(Integer)
    
    # 字符串类型
    name = Column(String(50))        # 最大 50 字符
    description = Column(Text)       # 长文本,无长度限制
    
    # 浮点数
    price = Column(Float)
    
    # 布尔值
    is_active = Column(Boolean, default=True)
    
    # 日期时间
    created_at = Column(DateTime)
    birth_date = Column(Date)
    login_time = Column(Time)
```

### 3.3 字段约束

```python
from sqlalchemy import Column, Integer, String

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True)              # 主键
    username = Column(String(50), unique=True)          # 唯一约束
    email = Column(String(100), nullable=False)         # 不能为空
    age = Column(Integer, default=18)                   # 默认值
    status = Column(String(20), index=True)             # 创建索引(加快查询)
```

### 3.4 Pydantic 模型 (schemas.py)

用于 API 的请求和响应验证。

```python
from pydantic import BaseModel, EmailStr
from typing import Optional
from datetime import datetime

# 创建用户时的请求模型
class UserCreate(BaseModel):
    username: str
    email: EmailStr  # 自动验证邮箱格式
    password: str

# 更新用户时的请求模型
class UserUpdate(BaseModel):
    username: Optional[str] = None
    email: Optional[EmailStr] = None
    is_active: Optional[bool] = None

# 返回给客户端的响应模型
class UserResponse(BaseModel):
    id: int
    username: str
    email: str
    is_active: bool
    created_at: datetime
    
    class Config:
        from_attributes = True  # 允许从 ORM 模型创建

# 商品模型
class ProductCreate(BaseModel):
    name: str
    description: Optional[str] = None
    price: float
    stock: int = 0

class ProductResponse(BaseModel):
    id: int
    name: str
    description: Optional[str]
    price: float
    stock: int
    is_available: bool
    created_at: datetime
    
    class Config:
        from_attributes = True
```

## 四、CRUD 操作

### 4.1 基础 CRUD (crud.py)

```python
from sqlalchemy.orm import Session
from models import User, Product
from schemas import UserCreate, ProductCreate
import hashlib

# ============= 用户 CRUD =============

def get_user(db: Session, user_id: int):
    """根据 ID 获取用户"""
    return db.query(User).filter(User.id == user_id).first()

def get_user_by_username(db: Session, username: str):
    """根据用户名获取用户"""
    return db.query(User).filter(User.username == username).first()

def get_users(db: Session, skip: int = 0, limit: int = 100):
    """获取用户列表(分页)"""
    return db.query(User).offset(skip).limit(limit).all()

def create_user(db: Session, user: UserCreate):
    """创建新用户"""
    # 简单的密码哈希(实际应用中使用 bcrypt 或 passlib)
    hashed_password = hashlib.sha256(user.password.encode()).hexdigest()
    
    db_user = User(
        username=user.username,
        email=user.email,
        hashed_password=hashed_password
    )
    db.add(db_user)      # 添加到会话
    db.commit()          # 提交到数据库
    db.refresh(db_user)  # 刷新对象,获取数据库生成的 ID 等
    return db_user

def update_user(db: Session, user_id: int, username: str = None, email: str = None):
    """更新用户信息"""
    db_user = db.query(User).filter(User.id == user_id).first()
    if db_user:
        if username:
            db_user.username = username
        if email:
            db_user.email = email
        db.commit()
        db.refresh(db_user)
    return db_user

def delete_user(db: Session, user_id: int):
    """删除用户"""
    db_user = db.query(User).filter(User.id == user_id).first()
    if db_user:
        db.delete(db_user)
        db.commit()
        return True
    return False

# ============= 商品 CRUD =============

def get_products(db: Session, skip: int = 0, limit: int = 100):
    """获取商品列表"""
    return db.query(Product).offset(skip).limit(limit).all()

def get_product(db: Session, product_id: int):
    """根据 ID 获取商品"""
    return db.query(Product).filter(Product.id == product_id).first()

def create_product(db: Session, product: ProductCreate):
    """创建新商品"""
    db_product = Product(**product.dict())
    db.add(db_product)
    db.commit()
    db.refresh(db_product)
    return db_product

def update_product_stock(db: Session, product_id: int, quantity: int):
    """更新商品库存"""
    db_product = db.query(Product).filter(Product.id == product_id).first()
    if db_product:
        db_product.stock += quantity
        db.commit()
        db.refresh(db_product)
    return db_product
```

### 4.2 高级查询

```python
from sqlalchemy import and_, or_, not_
from sqlalchemy.orm import Session
from models import User, Product

def advanced_queries(db: Session):
    """高级查询示例"""
    
    # 1. 条件查询
    active_users = db.query(User).filter(User.is_active == True).all()
    
    # 2. 多个条件 (AND)
    users = db.query(User).filter(
        User.is_active == True,
        User.username.like("%张%")  # 模糊查询
    ).all()
    
    # 或者使用 and_
    users = db.query(User).filter(
        and_(User.is_active == True, User.username.like("%张%"))
    ).all()
    
    # 3. OR 查询
    users = db.query(User).filter(
        or_(User.username == "张三", User.username == "李四")
    ).all()
    
    # 4. NOT 查询
    users = db.query(User).filter(
        not_(User.is_active == True)
    ).all()
    
    # 5. IN 查询
    users = db.query(User).filter(
        User.id.in_([1, 2, 3, 4, 5])
    ).all()
    
    # 6. 排序
    users = db.query(User).order_by(User.created_at.desc()).all()  # 降序
    users = db.query(User).order_by(User.username.asc()).all()     # 升序
    
    # 7. 限制数量
    first_user = db.query(User).first()  # 第一条
    users = db.query(User).limit(10).all()  # 前 10 条
    
    # 8. 分页
    page = 1
    page_size = 20
    users = db.query(User).offset((page - 1) * page_size).limit(page_size).all()
    
    # 9. 统计数量
    user_count = db.query(User).count()
    active_count = db.query(User).filter(User.is_active == True).count()
    
    # 10. 价格区间查询
    products = db.query(Product).filter(
        Product.price >= 100,
        Product.price <= 500
    ).all()
    
    # 11. 模糊查询
    products = db.query(Product).filter(
        Product.name.like("%手机%")
    ).all()
    
    # 12. 只查询某些字段
    usernames = db.query(User.username, User.email).all()
    
    return users
```

## 五、集成到 FastAPI

### 5.1 创建数据库表 (main.py)

```python
from fastapi import FastAPI
from database import engine, Base
from routers import users, products

# 创建所有表
Base.metadata.create_all(bind=engine)

app = FastAPI(title="FastAPI + SQLAlchemy 示例")

# 包含路由
app.include_router(users.router)
app.include_router(products.router)

@app.get("/")
def root():
    return {"message": "欢迎使用 API"}
```

### 5.2 用户路由 (routers/users.py)

```python
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List

from database import get_db
from schemas import UserCreate, UserResponse, UserUpdate
import crud

router = APIRouter(
    prefix="/api/users",
    tags=["用户管理"]
)

@router.post("/", response_model=UserResponse, status_code=201)
def create_user(user: UserCreate, db: Session = Depends(get_db)):
    """创建新用户"""
    # 检查用户名是否已存在
    db_user = crud.get_user_by_username(db, username=user.username)
    if db_user:
        raise HTTPException(status_code=400, detail="用户名已存在")
    
    return crud.create_user(db=db, user=user)

@router.get("/", response_model=List[UserResponse])
def read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    """获取用户列表"""
    users = crud.get_users(db, skip=skip, limit=limit)
    return users

@router.get("/{user_id}", response_model=UserResponse)
def read_user(user_id: int, db: Session = Depends(get_db)):
    """获取单个用户"""
    db_user = crud.get_user(db, user_id=user_id)
    if db_user is None:
        raise HTTPException(status_code=404, detail="用户不存在")
    return db_user

@router.put("/{user_id}", response_model=UserResponse)
def update_user(user_id: int, user: UserUpdate, db: Session = Depends(get_db)):
    """更新用户信息"""
    db_user = crud.update_user(
        db, 
        user_id=user_id, 
        username=user.username, 
        email=user.email
    )
    if db_user is None:
        raise HTTPException(status_code=404, detail="用户不存在")
    return db_user

@router.delete("/{user_id}")
def delete_user(user_id: int, db: Session = Depends(get_db)):
    """删除用户"""
    success = crud.delete_user(db, user_id=user_id)
    if not success:
        raise HTTPException(status_code=404, detail="用户不存在")
    return {"message": "删除成功"}
```

### 5.3 商品路由 (routers/products.py)

```python
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List

from database import get_db
from schemas import ProductCreate, ProductResponse
import crud

router = APIRouter(
    prefix="/api/products",
    tags=["商品管理"]
)

@router.post("/", response_model=ProductResponse, status_code=201)
def create_product(product: ProductCreate, db: Session = Depends(get_db)):
    """创建新商品"""
    return crud.create_product(db=db, product=product)

@router.get("/", response_model=List[ProductResponse])
def read_products(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    """获取商品列表"""
    products = crud.get_products(db, skip=skip, limit=limit)
    return products

@router.get("/{product_id}", response_model=ProductResponse)
def read_product(product_id: int, db: Session = Depends(get_db)):
    """获取单个商品"""
    db_product = crud.get_product(db, product_id=product_id)
    if db_product is None:
        raise HTTPException(status_code=404, detail="商品不存在")
    return db_product

@router.patch("/{product_id}/stock")
def update_stock(product_id: int, quantity: int, db: Session = Depends(get_db)):
    """更新库存"""
    db_product = crud.update_product_stock(db, product_id=product_id, quantity=quantity)
    if db_product is None:
        raise HTTPException(status_code=404, detail="商品不存在")
    return {"message": "库存更新成功", "new_stock": db_product.stock}
```

## 六、表关系

### 6.1 一对多关系

```python
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship
from database import Base

class Author(Base):
    """作者表"""
    __tablename__ = "authors"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(50), nullable=False)
    
    # 定义关系:一个作者有多本书
    books = relationship("Book", back_populates="author")

class Book(Base):
    """书籍表"""
    __tablename__ = "books"
    
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String(100), nullable=False)
    author_id = Column(Integer, ForeignKey("authors.id"))  # 外键
    
    # 定义关系:每本书属于一个作者
    author = relationship("Author", back_populates="books")

# 使用示例
def create_author_with_books(db: Session):
    # 创建作者
    author = Author(name="鲁迅")
    
    # 创建书籍
    book1 = Book(title="呐喊", author=author)
    book2 = Book(title="彷徨", author=author)
    
    db.add(author)
    db.commit()
    
    # 查询作者的所有书籍
    author = db.query(Author).filter(Author.name == "鲁迅").first()
    for book in author.books:
        print(book.title)
```

### 6.2 多对多关系

```python
from sqlalchemy import Table, Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship
from database import Base

# 中间表(学生-课程关系)
student_course = Table(
    'student_course',
    Base.metadata,
    Column('student_id', Integer, ForeignKey('students.id')),
    Column('course_id', Integer, ForeignKey('courses.id'))
)

class Student(Base):
    """学生表"""
    __tablename__ = "students"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(50), nullable=False)
    
    # 多对多关系
    courses = relationship("Course", secondary=student_course, back_populates="students")

class Course(Base):
    """课程表"""
    __tablename__ = "courses"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), nullable=False)
    
    # 多对多关系
    students = relationship("Student", secondary=student_course, back_populates="courses")

# 使用示例
def enroll_student(db: Session):
    # 创建学生
    student = Student(name="张三")
    
    # 创建课程
    course1 = Course(name="数学")
    course2 = Course(name="英语")
    
    # 学生选课
    student.courses.append(course1)
    student.courses.append(course2)
    
    db.add(student)
    db.commit()
    
    # 查询学生的所有课程
    student = db.query(Student).filter(Student.name == "张三").first()
    for course in student.courses:
        print(course.name)
```

## 七、实战:完整的订单系统

### 7.1 数据库模型

```python
from sqlalchemy import Column, Integer, String, Float, ForeignKey, DateTime
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from database import Base

class User(Base):
    """用户表"""
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String(50), unique=True, nullable=False)
    email = Column(String(100), unique=True, nullable=False)
    hashed_password = Column(String(200), nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # 关系:一个用户有多个订单
    orders = relationship("Order", back_populates="user")

class Product(Base):
    """商品表"""
    __tablename__ = "products"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), nullable=False)
    price = Column(Float, nullable=False)
    stock = Column(Integer, default=0)
    
    # 关系:一个商品可以在多个订单项中
    order_items = relationship("OrderItem", back_populates="product")

class Order(Base):
    """订单表"""
    __tablename__ = "orders"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    total_price = Column(Float, default=0)
    status = Column(String(20), default="pending")  # pending, completed, cancelled
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # 关系
    user = relationship("User", back_populates="orders")
    items = relationship("OrderItem", back_populates="order")

class OrderItem(Base):
    """订单项表"""
    __tablename__ = "order_items"
    
    id = Column(Integer, primary_key=True, index=True)
    order_id = Column(Integer, ForeignKey("orders.id"))
    product_id = Column(Integer, ForeignKey("products.id"))
    quantity = Column(Integer, nullable=False)
    price = Column(Float, nullable=False)  # 下单时的价格
    
    # 关系
    order = relationship("Order", back_populates="items")
    product = relationship("Product", back_populates="order_items")
```

### 7.2 CRUD 操作

```python
from sqlalchemy.orm import Session
from models import Order, OrderItem, Product

def create_order(db: Session, user_id: int, items: list):
    """
    创建订单
    items: [{"product_id": 1, "quantity": 2}, ...]
    """
    # 创建订单
    order = Order(user_id=user_id)
    db.add(order)
    db.flush()  # 获取 order.id,但不提交
    
    total_price = 0
    
    # 添加订单项
    for item in items:
        product = db.query(Product).filter(Product.id == item["product_id"]).first()
        
        if not product:
            raise ValueError(f"商品 {item['product_id']} 不存在")
        
        if product.stock < item["quantity"]:
            raise ValueError(f"商品 {product.name} 库存不足")
        
        # 创建订单项
        order_item = OrderItem(
            order_id=order.id,
            product_id=product.id,
            quantity=item["quantity"],
            price=product.price
        )
        db.add(order_item)
        
        # 减少库存
        product.stock -= item["quantity"]
        
        # 计算总价
        total_price += product.price * item["quantity"]
    
    order.total_price = total_price
    db.commit()
    db.refresh(order)
    
    return order

def get_user_orders(db: Session, user_id: int):
    """获取用户的所有订单"""
    return db.query(Order).filter(Order.user_id == user_id).all()

def get_order_detail(db: Session, order_id: int):
    """获取订单详情(包括订单项)"""
    order = db.query(Order).filter(Order.id == order_id).first()
    return order  # order.items 会自动加载订单项
```

## 八、数据库迁移 (Alembic)

当数据库结构需要修改时,使用 Alembic 进行版本管理。

### 8.1 安装和初始化

```bash
# 安装 Alembic
pip install alembic

# 初始化 Alembic
alembic init alembic
```

### 8.2 配置 (alembic/env.py)

```python
from logging.config import fileConfig
from sqlalchemy import engine_from_config
from sqlalchemy import pool
from alembic import context

# 导入你的模型
from database import Base
from models import User, Product, Order, OrderItem

# Alembic Config 对象
config = context.config

# 设置数据库 URL
config.set_main_option("sqlalchemy.url", "sqlite:///./myapp.db")

# 设置 target_metadata
target_metadata = Base.metadata

# ... 其他配置
```

### 8.3 创建和应用迁移

```bash
# 创建迁移文件
alembic revision --autogenerate -m "Add user table"

# 应用迁移
alembic upgrade head

# 回退迁移
alembic downgrade -1
```

## 九、常见问题

### Q1: SQLAlchemy 模型和 Pydantic 模型有什么区别?

- **SQLAlchemy 模型**: 用于数据库操作,定义表结构
- **Pydantic 模型**: 用于 API 验证,定义请求/响应格式

### Q2: 什么时候用 commit() 和 flush()?

- `flush()`: 将更改发送到数据库,但不提交事务
- `commit()`: 提交事务,使更改永久生效

### Q3: 如何处理密码?

永远不要明文存储密码!使用 `passlib` 或 `bcrypt` 加密:

```bash
pip install passlib[bcrypt]
```

### Q4: 如何切换数据库?

只需修改 `database.py` 中的 `SQLALCHEMY_DATABASE_URL`:

```python
# MySQL
SQLALCHEMY_DATABASE_URL = "mysql+pymysql://user:password@localhost/dbname"

# PostgreSQL
SQLALCHEMY_DATABASE_URL = "postgresql://user:password@localhost/dbname"
```

## 十、完整运行步骤

```bash
# 1. 创建项目结构
mkdir my_project
cd my_project
touch main.py database.py models.py schemas.py crud.py
mkdir routers
touch routers/users.py

# 2. 安装依赖
pip install fastapi sqlalchemy uvicorn

# 3. 运行应用
uvicorn main:app --reload

# 4. 访问文档
# 浏览器打开: http://localhost:8000/docs

# 5. 测试 API
# 创建用户、查询用户等
```

## 十一、最佳实践

1. **分离关注点**: models (数据库) → schemas (验证) → crud (操作) → routers (路由)
2. **使用依赖注入**: `Depends(get_db)` 自动管理数据库会话
3. **异常处理**: 使用 `HTTPException` 返回友好的错误信息
4. **数据验证**: 使用 Pydantic 模型验证输入
5. **密码安全**: 使用 bcrypt 或 passlib 加密密码
6. **事务管理